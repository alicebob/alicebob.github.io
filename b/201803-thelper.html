<!DOCTYPE html>
<html>
<head>
    <title>Reworking Go table tests</title>
    <link rel="icon" type="image/png" href="../img/shark.png">
    <style>
@font-face {
    font-family: 'Noto Sans';
    font-style: normal;
    font-weight: normal;
    src: local('Noto Sans'), local('NotoSans'), url(../img/notosans-regular.ttf) format('truetype');
}
html {
    height: 100%;
}
body {
    margin: 0;
    margin-left: 100px;
    display: grid;
    grid-template-rows: max-content auto max-content;
    height: 100%;
    max-width: 700px;
    font-family: "Noto Sans", sans-serif;
}
a, a:visited {
    color: black;
    font-weight: bolder;
}
nav {
    padding: 3em 1em;
    border-bottom: solid 2px #666;
    margin-bottom: 3em;
    word-spacing: 1em;
}
.logo {
    font-size: 200%;
    color: #2098a3;
}
article {
    text-align: justify;
}
footer {
    border-top: solid 2px #666;
    padding-top: 1em;
    margin-top: 1em;
}
.date {
    text-align: right;
    padding-bottom: 3em;
}
    </style>
</head>
<body>
    <nav>
        <span class="logo">Alicebob</span> <a href="../index.html">home</a>
        <a href="../projects.html">projects</a>
        <a href="index.html">articles</a>
    </nav>
    <article>
        <div class="date"> 
Berlin, April 2018
</div>

<p>While working on <a href="https://github.com/alicebob/sqlittle">SQLittle</a> I wrote some test in (my) usual table driven test style. The idea is to loop over test cases when testing a list of permutations, without too much boilerplate:</p>

<pre>
func TestRecord(t *testing.T) {
    for i, cas := range []struct {
        e    string
        want []interface{}
        err  error
    }{
        {
            // type 1: 8 bit
            e:    "\x02\x01P",
            want: []interface{}{int64(80)},
        },
        {
            // type 1: 8 bit
            e:    "\x02\x01\xb0",
            want: []interface{}{-int64(80)},
        },
        {
            // type 2: 16 bit
            e:    "\x02\x02@\x00",
            want: []interface{}{int64(1 &lt;&lt; 14)},
        },
        //  ... few pages of this ...
     } {
        e, err := parseRecord([]byte(cas.e))
        if have, want := err, cas.err; !reflect.DeepEqual(have, want) {
            t.Fatalf("case %d: have %v, want %v", i, have, want)
        }
        if have, want := e, cas.want; !reflect.DeepEqual(have, want) {
            t.Errorf("case %d: have\n-[[%#v]], want\n-[[%#v]]", i, have, want)
        }
    }
}
</pre>

<p>Pretty good, since it&rsquo;s easy to add tests, with minimal new code. When a test fails you get the number of the failed entry and you can sorta figure it which one it is, but it&rsquo;s not great.</p>

<p>But, since Go 1.9 there is the <code>t.Helper()</code> function. Using that I
can rewrite the above in:</p>

<pre>
func TestRecord(t *testing.T) {
    test := func(e string, want []interface{}, wantErr error) {
        t.Helper()
        parsed, err := parseRecord([]byte(e))
        if have, want := err, wantErr; !reflect.DeepEqual(have, want) {
            t.Fatalf("have %v, want %v", have, want)
        }
        if have, want := parsed, want; !reflect.DeepEqual(have, want) {
            t.Errorf("have\n-[[%#v]], want\n-[[%#v]]", have, want)
        }
    }
    test(
        // type 1: 8 bit
        "\x02\x01P",
        []interface{}{int64(80)},
        nil,
    )
    test(
        // type 1: 8 bit
        "\x02\x01\xb0",
        []interface{}{-int64(80)},
        nil,
    )
    // still a few pages of this
}
</pre>

<p>Much cleaner, and when a test fails it points to the calling
<code>test()</code> function, not the <code>t.Errorf()</code> line.</p>

    </article>
    <footer></footer>
</body>
</html>
